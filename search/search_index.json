{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary confsecrets is a library providing secure symmetric cryptography based on PyCrypto, pycryptodome, or pycryptodomex to any Python project. A set of secrets are collected into a \"vault\" which is stored as a JSON file. All secrets share the same salt and binary key. The binary key is derived from a clear text key via PBKDF2. Installation confsecrets is best installed from your Python Package repository: pip install confsecrets This provides one top-level packages: confsecrets - general support for secrets management There is also a confsecrets command that you can use to create a new salt, manage the vault, etc. Environment Variables confsecrets.vault.DefaultVault and the command-line, use the following environment variables: CONFSECRETS_SALT - a base64 encoded, 8-byte salt CONFSECRETS_KEY - a plain text password or passphrase from which the binary key is derived CONFSECSETS_PATH - The path to a JSON-encoded vault file, which will be initialized if needed Console Comands confsecrets newsalt - creates a new, base-64 encoded salt. The --raw argument causes this to be printed as python code, to be copied into a file. confsecrets list - lists all secrets in a vault. confsecrets get <secret> - gets a single secret. confsecrets put <secret> <value> - updates a secret to the given value confsecrets rm <secret> - removes a secret from a vault","title":"Getting Started"},{"location":"#summary","text":"confsecrets is a library providing secure symmetric cryptography based on PyCrypto, pycryptodome, or pycryptodomex to any Python project. A set of secrets are collected into a \"vault\" which is stored as a JSON file. All secrets share the same salt and binary key. The binary key is derived from a clear text key via PBKDF2.","title":"Summary"},{"location":"#installation","text":"confsecrets is best installed from your Python Package repository: pip install confsecrets This provides one top-level packages: confsecrets - general support for secrets management There is also a confsecrets command that you can use to create a new salt, manage the vault, etc.","title":"Installation"},{"location":"#environment-variables","text":"confsecrets.vault.DefaultVault and the command-line, use the following environment variables: CONFSECRETS_SALT - a base64 encoded, 8-byte salt CONFSECRETS_KEY - a plain text password or passphrase from which the binary key is derived CONFSECSETS_PATH - The path to a JSON-encoded vault file, which will be initialized if needed","title":"Environment Variables"},{"location":"#console-comands","text":"confsecrets newsalt - creates a new, base-64 encoded salt. The --raw argument causes this to be printed as python code, to be copied into a file. confsecrets list - lists all secrets in a vault. confsecrets get <secret> - gets a single secret. confsecrets put <secret> <value> - updates a secret to the given value confsecrets rm <secret> - removes a secret from a vault","title":"Console Comands"},{"location":"api/","text":"confsecrets.pbe Provides secure, symmetric encryption without much around it. Includes these exceptions: confsecrets.pbe.InvalidSalt - raised for an invalid salt confsecrets.pbe.MessageTooShort - raised when attempting to decrypt a message that has no room for IV, ciphertext, and MAC confsecrets.pbe.InvalidMessageAuthenticationCode - raised when decrypting a message with an invalid MAC confsecrets.pbe.PasswordTooSimple - raised when PasswordUtil receives a password that is not complex enough. confsecrets.pbe.PasswordNotShellSafe - raised when PasswordUtil receives a password that must be escaped from a Linux shell. Includes these types: confsecrets.pbe.PasswordUtil : PasswordUtil.check - a static method that checks a password for length, complexity, and shell safety. PasswordUtil.generate - a static method that generates a password matching above rules confsecrets.pbe.PBEUtil - This is the heart of the module, providing secure, symmetric encryption. confsecrets.vault Implements a file-based container of encrypted material. Each piece of encrypted material is accessed via a key. Includes these exceptions: confsecrets.vault.VaultPathMissing - raised when no path has been provided confsecrets.vault.VaultNotFound - raised for operating systems errors accessing the vault confsecrets.vault.VaultFormatError - raised when the vault is in an invalid format Includes these types: confsecrets.vault.Vault - A dictionary type that stores its values as encrypted, base64 encoded messages within a JSON or YAML file. confsecrets.vault.DefaultVault - A vault with global parameters that functions as a singleton confsecrets.secrets Provides objects that behave like strings or other types, which are backed by the vault. Includes these types: confsecrets.secrets.BaseSecret - A base secret simply knows how to set and get its value from a vault. If no vault is provided, it uses the DefaultVault . confsecrets.secrets.Secret - A secret that behaves like a string in string contexts, a bool in bool contexts, and so on.","title":"API Reference"},{"location":"api/#confsecretspbe","text":"Provides secure, symmetric encryption without much around it. Includes these exceptions: confsecrets.pbe.InvalidSalt - raised for an invalid salt confsecrets.pbe.MessageTooShort - raised when attempting to decrypt a message that has no room for IV, ciphertext, and MAC confsecrets.pbe.InvalidMessageAuthenticationCode - raised when decrypting a message with an invalid MAC confsecrets.pbe.PasswordTooSimple - raised when PasswordUtil receives a password that is not complex enough. confsecrets.pbe.PasswordNotShellSafe - raised when PasswordUtil receives a password that must be escaped from a Linux shell. Includes these types: confsecrets.pbe.PasswordUtil : PasswordUtil.check - a static method that checks a password for length, complexity, and shell safety. PasswordUtil.generate - a static method that generates a password matching above rules confsecrets.pbe.PBEUtil - This is the heart of the module, providing secure, symmetric encryption.","title":"confsecrets.pbe"},{"location":"api/#confsecretsvault","text":"Implements a file-based container of encrypted material. Each piece of encrypted material is accessed via a key. Includes these exceptions: confsecrets.vault.VaultPathMissing - raised when no path has been provided confsecrets.vault.VaultNotFound - raised for operating systems errors accessing the vault confsecrets.vault.VaultFormatError - raised when the vault is in an invalid format Includes these types: confsecrets.vault.Vault - A dictionary type that stores its values as encrypted, base64 encoded messages within a JSON or YAML file. confsecrets.vault.DefaultVault - A vault with global parameters that functions as a singleton","title":"confsecrets.vault"},{"location":"api/#confsecretssecrets","text":"Provides objects that behave like strings or other types, which are backed by the vault. Includes these types: confsecrets.secrets.BaseSecret - A base secret simply knows how to set and get its value from a vault. If no vault is provided, it uses the DefaultVault . confsecrets.secrets.Secret - A secret that behaves like a string in string contexts, a bool in bool contexts, and so on.","title":"confsecrets.secrets"},{"location":"django/","text":"Secrets Secrets are the primary way that confsecrets integrates with web frameworks like Django. These secrets are typically declared as static objects in your settings, like this: from confsecrets import Secret ... SOCK_COLOR = Secret('sockcolor', vault=VAULT) UNDERWEAR = Secret('has_underwear', vault=VAULT) Secrets behave like strings under the appropriate circumstance: print('His socks are %s' % settings.SOCK_COLOR) Secrets behave like booleans under the appropriate circumstance: print('He wears underwear' if settings.UNDERWEAR else 'He has no underwear') However, to use secrets, you must first declare a vault. Initializing the Vault You need to create the vault in your settings file: from confsecrets.vault import Vault from confsecrets.vault import Config ... VAULT = Vault( salt=b'abcd1234', key='Every good boy does fine', path=os.environ.get(Config.PATH.value) ) Note Putting the encrypted material (vault file), salt, and clear text key in the same git repository is no more than obfuscation. For best security, these should only come together on the developer's desktop, in continuous integration (Jenkins), and on deployed servers. Management Commands confsecrets has no management commands, because it is not a Django app. You can use the console command confsecrets instead. Common Errors If you use a secret that does not exist in the vault, you will get a KeyError , just as if you were accessing a value that is not present in a dictionary.","title":"Django Integration"},{"location":"django/#secrets","text":"Secrets are the primary way that confsecrets integrates with web frameworks like Django. These secrets are typically declared as static objects in your settings, like this: from confsecrets import Secret ... SOCK_COLOR = Secret('sockcolor', vault=VAULT) UNDERWEAR = Secret('has_underwear', vault=VAULT) Secrets behave like strings under the appropriate circumstance: print('His socks are %s' % settings.SOCK_COLOR) Secrets behave like booleans under the appropriate circumstance: print('He wears underwear' if settings.UNDERWEAR else 'He has no underwear') However, to use secrets, you must first declare a vault.","title":"Secrets"},{"location":"django/#initializing-the-vault","text":"You need to create the vault in your settings file: from confsecrets.vault import Vault from confsecrets.vault import Config ... VAULT = Vault( salt=b'abcd1234', key='Every good boy does fine', path=os.environ.get(Config.PATH.value) ) Note Putting the encrypted material (vault file), salt, and clear text key in the same git repository is no more than obfuscation. For best security, these should only come together on the developer's desktop, in continuous integration (Jenkins), and on deployed servers.","title":"Initializing the Vault"},{"location":"django/#management-commands","text":"confsecrets has no management commands, because it is not a Django app. You can use the console command confsecrets instead.","title":"Management Commands"},{"location":"django/#common-errors","text":"If you use a secret that does not exist in the vault, you will get a KeyError , just as if you were accessing a value that is not present in a dictionary.","title":"Common Errors"}]}